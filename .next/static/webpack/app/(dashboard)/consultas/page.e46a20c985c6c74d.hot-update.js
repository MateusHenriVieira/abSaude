"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/consultas/page",{

/***/ "(app-pages-browser)/./lib/doctor-scheduling.ts":
/*!**********************************!*\
  !*** ./lib/doctor-scheduling.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockTimeSlot: () => (/* binding */ blockTimeSlot),\n/* harmony export */   checkSlotsAvailability: () => (/* binding */ checkSlotsAvailability),\n/* harmony export */   cleanupExpiredBlocks: () => (/* binding */ cleanupExpiredBlocks),\n/* harmony export */   fetchDoctorWorkingHours: () => (/* binding */ fetchDoctorWorkingHours),\n/* harmony export */   generateAppointmentSlots: () => (/* binding */ generateAppointmentSlots),\n/* harmony export */   scheduleAppointment: () => (/* binding */ scheduleAppointment),\n/* harmony export */   unblockTimeSlot: () => (/* binding */ unblockTimeSlot)\n/* harmony export */ });\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/firebase */ \"(app-pages-browser)/./lib/firebase.ts\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _barrel_optimize_names_addMinutes_endOfDay_format_startOfDay_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=addMinutes,endOfDay,format,startOfDay!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/format.js\");\n/* harmony import */ var _barrel_optimize_names_addMinutes_endOfDay_format_startOfDay_date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=addMinutes,endOfDay,format,startOfDay!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/addMinutes.js\");\n/* harmony import */ var _barrel_optimize_names_addMinutes_endOfDay_format_startOfDay_date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=addMinutes,endOfDay,format,startOfDay!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/startOfDay.js\");\n/* harmony import */ var _barrel_optimize_names_addMinutes_endOfDay_format_startOfDay_date_fns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=addMinutes,endOfDay,format,startOfDay!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/endOfDay.js\");\n/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! date-fns/locale */ \"(app-pages-browser)/./node_modules/date-fns/locale/pt-BR.js\");\n\n\n\n\n/**\r\n * Fetches doctor working hours from Firestore\r\n * @param clinicId - The clinic ID\r\n * @param doctorId - The doctor ID\r\n * @returns The doctor's schedule including working days and hours\r\n */ async function fetchDoctorWorkingHours(clinicId, doctorId) {\n    try {\n        var _doctorData_schedule, _doctorData_schedule1;\n        // Reference to the doctor document in the clinic's doctors subcollection\n        const doctorRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"clinics\", clinicId, \"doctors\", doctorId);\n        const doctorDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(doctorRef);\n        if (!doctorDoc.exists()) {\n            throw new Error(\"Doctor with ID \".concat(doctorId, \" not found in clinic \").concat(clinicId));\n        }\n        const doctorData = doctorDoc.data();\n        // Extract schedule information\n        const workingDays = ((_doctorData_schedule = doctorData.schedule) === null || _doctorData_schedule === void 0 ? void 0 : _doctorData_schedule.workingDays) || [\n            \"segunda\",\n            \"terca\",\n            \"quarta\",\n            \"quinta\",\n            \"sexta\"\n        ];\n        const workingHours = ((_doctorData_schedule1 = doctorData.schedule) === null || _doctorData_schedule1 === void 0 ? void 0 : _doctorData_schedule1.workingHours) || {\n            start: \"08:00\",\n            end: \"18:00\"\n        };\n        const is24Hours = workingHours.start === \"00:00\" && workingHours.end === \"23:59\";\n        return {\n            workingDays,\n            workingHours,\n            is24Hours\n        };\n    } catch (error) {\n        console.error(\"Error fetching doctor working hours:\", error);\n        // Return default schedule if there's an error\n        return {\n            workingDays: [\n                \"segunda\",\n                \"terca\",\n                \"quarta\",\n                \"quinta\",\n                \"sexta\"\n            ],\n            workingHours: {\n                start: \"08:00\",\n                end: \"18:00\"\n            }\n        };\n    }\n}\n/**\r\n * Generates appointment slots based on doctor working hours\r\n * @param date - The date for which to generate slots\r\n * @param schedule - The doctor's schedule\r\n * @param slotDuration - Duration of each slot in minutes (default: 30)\r\n * @returns Array of appointment slots\r\n */ function generateAppointmentSlots(date, schedule) {\n    let slotDuration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 30;\n    try {\n        const slots = [];\n        // Check if the selected date is a working day\n        const weekDay = (0,_barrel_optimize_names_addMinutes_endOfDay_format_startOfDay_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(date, \"EEEE\", {\n            locale: date_fns_locale__WEBPACK_IMPORTED_MODULE_3__.ptBR\n        }).toLowerCase().normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").replace(\"-feira\", \"\");\n        if (!schedule.workingDays.includes(weekDay)) {\n            return slots // Return empty array if not a working day\n            ;\n        }\n        // Parse working hours\n        const [startHour, startMinute] = schedule.workingHours.start.split(\":\").map(Number);\n        const [endHour, endMinute] = schedule.workingHours.end.split(\":\").map(Number);\n        // Create start and end date objects\n        const startDate = new Date(date);\n        startDate.setHours(startHour, startMinute, 0, 0);\n        const endDate = new Date(date);\n        endDate.setHours(endHour, endMinute, 0, 0);\n        // Generate slots\n        let currentSlot = startDate;\n        while(currentSlot < endDate){\n            slots.push({\n                time: (0,_barrel_optimize_names_addMinutes_endOfDay_format_startOfDay_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(currentSlot, \"HH:mm\"),\n                isAvailable: true\n            });\n            currentSlot = (0,_barrel_optimize_names_addMinutes_endOfDay_format_startOfDay_date_fns__WEBPACK_IMPORTED_MODULE_4__.addMinutes)(currentSlot, slotDuration);\n        }\n        return slots;\n    } catch (error) {\n        console.error(\"Error generating appointment slots:\", error);\n        return [];\n    }\n}\n/**\r\n * Checks availability of appointment slots in Firestore\r\n * @param clinicId - The clinic ID\r\n * @param date - The date to check\r\n * @param doctorId - The doctor ID (optional)\r\n * @returns Array of available time slots\r\n */ async function checkSlotsAvailability(clinicId, date, doctorId) {\n    try {\n        // Get reference to appointments collection\n        const appointmentsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"appointments\");\n        // Create date range for the selected date\n        const dayStart = (0,_barrel_optimize_names_addMinutes_endOfDay_format_startOfDay_date_fns__WEBPACK_IMPORTED_MODULE_5__.startOfDay)(date);\n        const dayEnd = (0,_barrel_optimize_names_addMinutes_endOfDay_format_startOfDay_date_fns__WEBPACK_IMPORTED_MODULE_6__.endOfDay)(date);\n        // Build query based on parameters\n        let appointmentsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(appointmentsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"clinicId\", \"==\", clinicId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"date\", \">=\", firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.fromDate(dayStart)), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"date\", \"<=\", firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.fromDate(dayEnd)));\n        // Add doctor filter if provided\n        if (doctorId) {\n            appointmentsQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(appointmentsRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"clinicId\", \"==\", clinicId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"doctorId\", \"==\", doctorId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"date\", \">=\", firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.fromDate(dayStart)), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"date\", \"<=\", firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.fromDate(dayEnd)));\n        }\n        // Execute query\n        const appointments = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(appointmentsQuery);\n        // Extract booked time slots\n        const bookedSlots = new Set(appointments.docs.map((doc)=>(0,_barrel_optimize_names_addMinutes_endOfDay_format_startOfDay_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(doc.data().date.toDate(), \"HH:mm\")));\n        // If doctor ID is provided, get their schedule\n        let doctorSchedule;\n        if (doctorId) {\n            doctorSchedule = await fetchDoctorWorkingHours(clinicId, doctorId);\n        } else {\n            // Default schedule if no doctor specified\n            doctorSchedule = {\n                workingDays: [\n                    \"segunda\",\n                    \"terca\",\n                    \"quarta\",\n                    \"quinta\",\n                    \"sexta\"\n                ],\n                workingHours: {\n                    start: \"08:00\",\n                    end: \"18:00\"\n                }\n            };\n        }\n        // Generate all possible slots for the day\n        const allSlots = generateAppointmentSlots(date, doctorSchedule);\n        // Filter out booked slots\n        return allSlots.filter((slot)=>!bookedSlots.has(slot.time)).map((slot)=>slot.time);\n    } catch (error) {\n        console.error(\"Error checking slots availability:\", error);\n        return [];\n    }\n}\n/**\r\n * Temporarily blocks a time slot to prevent double bookings\r\n * @param clinicId - The clinic ID\r\n * @param doctorId - The doctor ID\r\n * @param date - The appointment date\r\n * @param time - The appointment time\r\n * @param blockDuration - How long to block the slot in minutes (default: 10)\r\n * @returns ID of the temporary block document\r\n */ async function blockTimeSlot(clinicId, doctorId, date, time) {\n    let blockDuration = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 10;\n    try {\n        // Create a reference to the temporary blocks collection\n        const tempBlocksRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"temporaryBlocks\");\n        // Parse time and create a Date object\n        const [hours, minutes] = time.split(\":\").map(Number);\n        const appointmentDate = new Date(date);\n        appointmentDate.setHours(hours, minutes, 0, 0);\n        // Calculate expiration time\n        const expirationTime = (0,_barrel_optimize_names_addMinutes_endOfDay_format_startOfDay_date_fns__WEBPACK_IMPORTED_MODULE_4__.addMinutes)(new Date(), blockDuration);\n        // Create a unique ID for the block\n        const blockId = \"\".concat(clinicId, \"_\").concat(doctorId, \"_\").concat((0,_barrel_optimize_names_addMinutes_endOfDay_format_startOfDay_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(appointmentDate, \"yyyy-MM-dd_HH-mm\"));\n        // Create the block document\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(tempBlocksRef, blockId), {\n            clinicId,\n            doctorId,\n            date: firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.fromDate(appointmentDate),\n            time,\n            blockedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n            expiresAt: firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.fromDate(expirationTime),\n            status: \"blocked\"\n        });\n        return blockId;\n    } catch (error) {\n        console.error(\"Error blocking time slot:\", error);\n        throw error;\n    }\n}\n/**\r\n * Schedules an appointment in Firestore\r\n * @param appointmentData - The appointment data\r\n * @param blockId - ID of the temporary block (optional)\r\n * @returns Object with appointment and consultation IDs\r\n */ async function scheduleAppointment(appointmentData, blockId) {\n    try {\n        const batch = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.writeBatch)(_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.db);\n        // Create appointment document\n        const appointmentsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"appointments\");\n        const appointmentRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(appointmentsRef);\n        // Create consultation document\n        const consultationsRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"consultations\");\n        const consultationRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(consultationsRef);\n        // Parse date and time\n        const dateTime = new Date(\"\".concat((0,_barrel_optimize_names_addMinutes_endOfDay_format_startOfDay_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(appointmentData.date, \"yyyy-MM-dd\"), \"T\").concat(appointmentData.time));\n        // Prepare appointment data\n        const appointmentDoc = {\n            id: appointmentRef.id,\n            type: \"consultation\",\n            consultationId: consultationRef.id,\n            clinicId: appointmentData.clinicId,\n            doctorId: appointmentData.doctorId,\n            patientName: appointmentData.patientName,\n            date: firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.fromDate(dateTime),\n            duration: 30,\n            status: \"Agendado\",\n            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n        };\n        // Prepare consultation data\n        const consultationDoc = {\n            id: consultationRef.id,\n            appointmentId: appointmentRef.id,\n            ...appointmentData,\n            date: firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.fromDate(dateTime),\n            status: \"Agendado\",\n            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n        };\n        // Add documents to batch\n        batch.set(appointmentRef, appointmentDoc);\n        batch.set(consultationRef, consultationDoc);\n        // If there's a block ID, update its status\n        if (blockId) {\n            const blockRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"temporaryBlocks\", blockId);\n            batch.update(blockRef, {\n                status: \"confirmed\",\n                appointmentId: appointmentRef.id,\n                consultationId: consultationRef.id\n            });\n        }\n        // Commit the batch\n        await batch.commit();\n        return {\n            appointmentId: appointmentRef.id,\n            consultationId: consultationRef.id\n        };\n    } catch (error) {\n        console.error(\"Error scheduling appointment:\", error);\n        throw error;\n    }\n}\n/**\r\n * Unblocks a time slot after scheduling or cancellation\r\n * @param blockId - ID of the temporary block\r\n * @param status - New status for the block (confirmed, cancelled, expired)\r\n */ async function unblockTimeSlot(blockId, status) {\n    try {\n        const blockRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"temporaryBlocks\", blockId);\n        const blockDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDoc)(blockRef);\n        // If block doesn't exist, it might have been already cleaned up or expired\n        if (!blockDoc.exists()) {\n            console.log(\"Block \".concat(blockId, \" not found - might have been already cleaned up or expired\"));\n            return;\n        }\n        if (status === \"confirmed\" || status === \"cancelled\") {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(blockRef, {\n                status,\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n            });\n        } else if (status === \"expired\") {\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.deleteDoc)(blockRef);\n        }\n    } catch (error) {\n        console.error(\"Error unblocking time slot:\", error);\n        // Don't throw error for non-critical operation\n        console.warn(\"Failed to unblock slot \".concat(blockId, \", but continuing operation\"));\n    }\n}\n/**\r\n * Cleans up expired temporary blocks\r\n * This function should be called periodically, e.g., by a scheduled function\r\n */ async function cleanupExpiredBlocks() {\n    try {\n        const tempBlocksRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.db, \"temporaryBlocks\");\n        const now = new Date();\n        // Query for expired blocks\n        const expiredBlocksQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)(tempBlocksRef, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"expiresAt\", \"<=\", firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp.fromDate(now)), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.where)(\"status\", \"==\", \"blocked\"));\n        const expiredBlocks = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(expiredBlocksQuery);\n        // Delete expired blocks\n        const batch = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.writeBatch)(_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.db);\n        expiredBlocks.docs.forEach((doc)=>{\n            batch.delete(doc.ref);\n        });\n        if (expiredBlocks.docs.length > 0) {\n            await batch.commit();\n            console.log(\"Cleaned up \".concat(expiredBlocks.docs.length, \" expired blocks\"));\n        }\n    } catch (error) {\n        console.error(\"Error cleaning up expired blocks:\", error);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9kb2N0b3Itc2NoZWR1bGluZy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQWNSO0FBQ3dDO0FBQzdCO0FBdUJ0Qzs7Ozs7Q0FLQyxHQUNNLGVBQWVrQix3QkFBd0JDLFFBQWdCLEVBQUVDLFFBQWdCO0lBQzlFLElBQUk7WUFZa0JDLHNCQUVDQTtRQWJyQix5RUFBeUU7UUFDekUsTUFBTUMsWUFBWXBCLHVEQUFHQSxDQUFDRiw2Q0FBRUEsRUFBRSxXQUFXbUIsVUFBVSxXQUFXQztRQUMxRCxNQUFNRyxZQUFZLE1BQU1wQiwwREFBTUEsQ0FBQ21CO1FBRS9CLElBQUksQ0FBQ0MsVUFBVUMsTUFBTSxJQUFJO1lBQ3ZCLE1BQU0sSUFBSUMsTUFBTSxrQkFBa0ROLE9BQWhDQyxVQUFTLHlCQUFnQyxPQUFURDtRQUNwRTtRQUVBLE1BQU1FLGFBQWFFLFVBQVVHLElBQUk7UUFFakMsK0JBQStCO1FBQy9CLE1BQU1DLGNBQWNOLEVBQUFBLHVCQUFBQSxXQUFXTyxRQUFRLGNBQW5CUCwyQ0FBQUEscUJBQXFCTSxXQUFXLEtBQUk7WUFBQztZQUFXO1lBQVM7WUFBVTtZQUFVO1NBQVE7UUFFekcsTUFBTUUsZUFBZVIsRUFBQUEsd0JBQUFBLFdBQVdPLFFBQVEsY0FBbkJQLDRDQUFBQSxzQkFBcUJRLFlBQVksS0FBSTtZQUN4REMsT0FBTztZQUNQQyxLQUFLO1FBQ1A7UUFFQSxNQUFNQyxZQUFZSCxhQUFhQyxLQUFLLEtBQUssV0FBV0QsYUFBYUUsR0FBRyxLQUFLO1FBRXpFLE9BQU87WUFDTEo7WUFDQUU7WUFDQUc7UUFDRjtJQUNGLEVBQUUsT0FBT0MsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsd0NBQXdDQTtRQUN0RCw4Q0FBOEM7UUFDOUMsT0FBTztZQUNMTixhQUFhO2dCQUFDO2dCQUFXO2dCQUFTO2dCQUFVO2dCQUFVO2FBQVE7WUFDOURFLGNBQWM7Z0JBQUVDLE9BQU87Z0JBQVNDLEtBQUs7WUFBUTtRQUMvQztJQUNGO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDTSxTQUFTSSx5QkFBeUJDLElBQVUsRUFBRVIsUUFBd0I7UUFBRVMsZUFBQUEsaUVBQWU7SUFDNUYsSUFBSTtRQUNGLE1BQU1DLFFBQTJCLEVBQUU7UUFFbkMsOENBQThDO1FBQzlDLE1BQU1DLFVBQVUxQiw2R0FBTUEsQ0FBQ3VCLE1BQU0sUUFBUTtZQUFFSSxRQUFRdkIsaURBQUlBO1FBQUMsR0FDakR3QixXQUFXLEdBQ1hDLFNBQVMsQ0FBQyxPQUNWQyxPQUFPLENBQUMsb0JBQW9CLElBQzVCQSxPQUFPLENBQUMsVUFBVTtRQUVyQixJQUFJLENBQUNmLFNBQVNELFdBQVcsQ0FBQ2lCLFFBQVEsQ0FBQ0wsVUFBVTtZQUMzQyxPQUFPRCxNQUFNLDBDQUEwQzs7UUFDekQ7UUFFQSxzQkFBc0I7UUFDdEIsTUFBTSxDQUFDTyxXQUFXQyxZQUFZLEdBQUdsQixTQUFTQyxZQUFZLENBQUNDLEtBQUssQ0FBQ2lCLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNDO1FBQzVFLE1BQU0sQ0FBQ0MsU0FBU0MsVUFBVSxHQUFHdkIsU0FBU0MsWUFBWSxDQUFDRSxHQUFHLENBQUNnQixLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztRQUV0RSxvQ0FBb0M7UUFDcEMsTUFBTUcsWUFBWSxJQUFJQyxLQUFLakI7UUFDM0JnQixVQUFVRSxRQUFRLENBQUNULFdBQVdDLGFBQWEsR0FBRztRQUU5QyxNQUFNUyxVQUFVLElBQUlGLEtBQUtqQjtRQUN6Qm1CLFFBQVFELFFBQVEsQ0FBQ0osU0FBU0MsV0FBVyxHQUFHO1FBRXhDLGlCQUFpQjtRQUNqQixJQUFJSyxjQUFjSjtRQUNsQixNQUFPSSxjQUFjRCxRQUFTO1lBQzVCakIsTUFBTW1CLElBQUksQ0FBQztnQkFDVEMsTUFBTTdDLDZHQUFNQSxDQUFDMkMsYUFBYTtnQkFDMUJHLGFBQWE7WUFDZjtZQUNBSCxjQUFjMUMsaUhBQVVBLENBQUMwQyxhQUFhbkI7UUFDeEM7UUFFQSxPQUFPQztJQUNULEVBQUUsT0FBT0wsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsdUNBQXVDQTtRQUNyRCxPQUFPLEVBQUU7SUFDWDtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ00sZUFBZTJCLHVCQUF1QnpDLFFBQWdCLEVBQUVpQixJQUFVLEVBQUVoQixRQUFpQjtJQUMxRixJQUFJO1FBQ0YsMkNBQTJDO1FBQzNDLE1BQU15QyxrQkFBa0I1RCw4REFBVUEsQ0FBQ0QsNkNBQUVBLEVBQUU7UUFFdkMsMENBQTBDO1FBQzFDLE1BQU04RCxXQUFXL0MsaUhBQVVBLENBQUNxQjtRQUM1QixNQUFNMkIsU0FBUy9DLCtHQUFRQSxDQUFDb0I7UUFFeEIsa0NBQWtDO1FBQ2xDLElBQUk0QixvQkFBb0IzRCx5REFBS0EsQ0FDM0J3RCxpQkFDQXZELHlEQUFLQSxDQUFDLFlBQVksTUFBTWEsV0FDeEJiLHlEQUFLQSxDQUFDLFFBQVEsTUFBTUMseURBQVNBLENBQUMwRCxRQUFRLENBQUNILFlBQ3ZDeEQseURBQUtBLENBQUMsUUFBUSxNQUFNQyx5REFBU0EsQ0FBQzBELFFBQVEsQ0FBQ0Y7UUFHekMsZ0NBQWdDO1FBQ2hDLElBQUkzQyxVQUFVO1lBQ1o0QyxvQkFBb0IzRCx5REFBS0EsQ0FDdkJ3RCxpQkFDQXZELHlEQUFLQSxDQUFDLFlBQVksTUFBTWEsV0FDeEJiLHlEQUFLQSxDQUFDLFlBQVksTUFBTWMsV0FDeEJkLHlEQUFLQSxDQUFDLFFBQVEsTUFBTUMseURBQVNBLENBQUMwRCxRQUFRLENBQUNILFlBQ3ZDeEQseURBQUtBLENBQUMsUUFBUSxNQUFNQyx5REFBU0EsQ0FBQzBELFFBQVEsQ0FBQ0Y7UUFFM0M7UUFFQSxnQkFBZ0I7UUFDaEIsTUFBTUcsZUFBZSxNQUFNOUQsMkRBQU9BLENBQUM0RDtRQUVuQyw0QkFBNEI7UUFDNUIsTUFBTUcsY0FBYyxJQUFJQyxJQUFJRixhQUFhRyxJQUFJLENBQUNyQixHQUFHLENBQUMsQ0FBQzlDLE1BQVFXLDZHQUFNQSxDQUFDWCxJQUFJd0IsSUFBSSxHQUFHVSxJQUFJLENBQUNrQyxNQUFNLElBQUk7UUFFNUYsK0NBQStDO1FBQy9DLElBQUlDO1FBQ0osSUFBSW5ELFVBQVU7WUFDWm1ELGlCQUFpQixNQUFNckQsd0JBQXdCQyxVQUFVQztRQUMzRCxPQUFPO1lBQ0wsMENBQTBDO1lBQzFDbUQsaUJBQWlCO2dCQUNmNUMsYUFBYTtvQkFBQztvQkFBVztvQkFBUztvQkFBVTtvQkFBVTtpQkFBUTtnQkFDOURFLGNBQWM7b0JBQUVDLE9BQU87b0JBQVNDLEtBQUs7Z0JBQVE7WUFDL0M7UUFDRjtRQUVBLDBDQUEwQztRQUMxQyxNQUFNeUMsV0FBV3JDLHlCQUF5QkMsTUFBTW1DO1FBRWhELDBCQUEwQjtRQUMxQixPQUFPQyxTQUFTQyxNQUFNLENBQUMsQ0FBQ0MsT0FBUyxDQUFDUCxZQUFZUSxHQUFHLENBQUNELEtBQUtoQixJQUFJLEdBQUdWLEdBQUcsQ0FBQyxDQUFDMEIsT0FBU0EsS0FBS2hCLElBQUk7SUFDdkYsRUFBRSxPQUFPekIsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsc0NBQXNDQTtRQUNwRCxPQUFPLEVBQUU7SUFDWDtBQUNGO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDTSxlQUFlMkMsY0FDcEJ6RCxRQUFnQixFQUNoQkMsUUFBZ0IsRUFDaEJnQixJQUFVLEVBQ1ZzQixJQUFZO1FBQ1ptQixnQkFBQUEsaUVBQWdCO0lBRWhCLElBQUk7UUFDRix3REFBd0Q7UUFDeEQsTUFBTUMsZ0JBQWdCN0UsOERBQVVBLENBQUNELDZDQUFFQSxFQUFFO1FBRXJDLHNDQUFzQztRQUN0QyxNQUFNLENBQUMrRSxPQUFPQyxRQUFRLEdBQUd0QixLQUFLWCxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztRQUM3QyxNQUFNZ0Msa0JBQWtCLElBQUk1QixLQUFLakI7UUFDakM2QyxnQkFBZ0IzQixRQUFRLENBQUN5QixPQUFPQyxTQUFTLEdBQUc7UUFFNUMsNEJBQTRCO1FBQzVCLE1BQU1FLGlCQUFpQnBFLGlIQUFVQSxDQUFDLElBQUl1QyxRQUFRd0I7UUFFOUMsbUNBQW1DO1FBQ25DLE1BQU1NLFVBQVUsR0FBZS9ELE9BQVpELFVBQVMsS0FBZU4sT0FBWk8sVUFBUyxLQUErQyxPQUE1Q1AsNkdBQU1BLENBQUNvRSxpQkFBaUI7UUFFbkUsNEJBQTRCO1FBQzVCLE1BQU16RSwwREFBTUEsQ0FBQ04sdURBQUdBLENBQUM0RSxlQUFlSyxVQUFVO1lBQ3hDaEU7WUFDQUM7WUFDQWdCLE1BQU03Qix5REFBU0EsQ0FBQzBELFFBQVEsQ0FBQ2dCO1lBQ3pCdkI7WUFDQTBCLFdBQVd6RSxtRUFBZUE7WUFDMUIwRSxXQUFXOUUseURBQVNBLENBQUMwRCxRQUFRLENBQUNpQjtZQUM5QkksUUFBUTtRQUNWO1FBRUEsT0FBT0g7SUFDVCxFQUFFLE9BQU9sRCxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyw2QkFBNkJBO1FBQzNDLE1BQU1BO0lBQ1I7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ00sZUFBZXNELG9CQUNwQkMsZUFBb0IsRUFDcEJMLE9BQWdCO0lBRWhCLElBQUk7UUFDRixNQUFNTSxRQUFRN0UsOERBQVVBLENBQUNaLDZDQUFFQTtRQUUzQiw4QkFBOEI7UUFDOUIsTUFBTTZELGtCQUFrQjVELDhEQUFVQSxDQUFDRCw2Q0FBRUEsRUFBRTtRQUN2QyxNQUFNMEYsaUJBQWlCeEYsdURBQUdBLENBQUMyRDtRQUUzQiwrQkFBK0I7UUFDL0IsTUFBTThCLG1CQUFtQjFGLDhEQUFVQSxDQUFDRCw2Q0FBRUEsRUFBRTtRQUN4QyxNQUFNNEYsa0JBQWtCMUYsdURBQUdBLENBQUN5RjtRQUU1QixzQkFBc0I7UUFDdEIsTUFBTUUsV0FBVyxJQUFJeEMsS0FBSyxHQUFpRG1DLE9BQTlDM0UsNkdBQU1BLENBQUMyRSxnQkFBZ0JwRCxJQUFJLEVBQUUsZUFBYyxLQUF3QixPQUFyQm9ELGdCQUFnQjlCLElBQUk7UUFFL0YsMkJBQTJCO1FBQzNCLE1BQU1vQyxpQkFBaUI7WUFDckJDLElBQUlMLGVBQWVLLEVBQUU7WUFDckJDLE1BQU07WUFDTkMsZ0JBQWdCTCxnQkFBZ0JHLEVBQUU7WUFDbEM1RSxVQUFVcUUsZ0JBQWdCckUsUUFBUTtZQUNsQ0MsVUFBVW9FLGdCQUFnQnBFLFFBQVE7WUFDbEM4RSxhQUFhVixnQkFBZ0JVLFdBQVc7WUFDeEM5RCxNQUFNN0IseURBQVNBLENBQUMwRCxRQUFRLENBQUM0QjtZQUN6Qk0sVUFBVTtZQUNWYixRQUFRO1lBQ1JjLFdBQVd6RixtRUFBZUE7UUFDNUI7UUFFQSw0QkFBNEI7UUFDNUIsTUFBTTBGLGtCQUFrQjtZQUN0Qk4sSUFBSUgsZ0JBQWdCRyxFQUFFO1lBQ3RCTyxlQUFlWixlQUFlSyxFQUFFO1lBQ2hDLEdBQUdQLGVBQWU7WUFDbEJwRCxNQUFNN0IseURBQVNBLENBQUMwRCxRQUFRLENBQUM0QjtZQUN6QlAsUUFBUTtZQUNSYyxXQUFXekYsbUVBQWVBO1FBQzVCO1FBRUEseUJBQXlCO1FBQ3pCOEUsTUFBTWMsR0FBRyxDQUFDYixnQkFBZ0JJO1FBQzFCTCxNQUFNYyxHQUFHLENBQUNYLGlCQUFpQlM7UUFFM0IsMkNBQTJDO1FBQzNDLElBQUlsQixTQUFTO1lBQ1gsTUFBTXFCLFdBQVd0Ryx1REFBR0EsQ0FBQ0YsNkNBQUVBLEVBQUUsbUJBQW1CbUY7WUFDNUNNLE1BQU1nQixNQUFNLENBQUNELFVBQVU7Z0JBQ3JCbEIsUUFBUTtnQkFDUmdCLGVBQWVaLGVBQWVLLEVBQUU7Z0JBQ2hDRSxnQkFBZ0JMLGdCQUFnQkcsRUFBRTtZQUNwQztRQUNGO1FBRUEsbUJBQW1CO1FBQ25CLE1BQU1OLE1BQU1pQixNQUFNO1FBRWxCLE9BQU87WUFDTEosZUFBZVosZUFBZUssRUFBRTtZQUNoQ0UsZ0JBQWdCTCxnQkFBZ0JHLEVBQUU7UUFDcEM7SUFDRixFQUFFLE9BQU85RCxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO1FBQy9DLE1BQU1BO0lBQ1I7QUFDRjtBQUVBOzs7O0NBSUMsR0FDTSxlQUFlMEUsZ0JBQWdCeEIsT0FBZSxFQUFFRyxNQUE2QztJQUNsRyxJQUFJO1FBQ0YsTUFBTWtCLFdBQVd0Ryx1REFBR0EsQ0FBQ0YsNkNBQUVBLEVBQUUsbUJBQW1CbUY7UUFDNUMsTUFBTXlCLFdBQVcsTUFBTXpHLDBEQUFNQSxDQUFDcUc7UUFFOUIsMkVBQTJFO1FBQzNFLElBQUksQ0FBQ0ksU0FBU3BGLE1BQU0sSUFBSTtZQUN0QlUsUUFBUTJFLEdBQUcsQ0FBQyxTQUFpQixPQUFSMUIsU0FBUTtZQUM3QjtRQUNGO1FBRUEsSUFBSUcsV0FBVyxlQUFlQSxXQUFXLGFBQWE7WUFDcEQsTUFBTTdFLDZEQUFTQSxDQUFDK0YsVUFBVTtnQkFDeEJsQjtnQkFDQXdCLFdBQVduRyxtRUFBZUE7WUFDNUI7UUFDRixPQUFPLElBQUkyRSxXQUFXLFdBQVc7WUFDL0IsTUFBTTVFLDZEQUFTQSxDQUFDOEY7UUFDbEI7SUFDRixFQUFFLE9BQU92RSxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQywrQkFBK0JBO1FBQzdDLCtDQUErQztRQUMvQ0MsUUFBUTZFLElBQUksQ0FBQywwQkFBa0MsT0FBUjVCLFNBQVE7SUFDakQ7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLGVBQWU2QjtJQUNwQixJQUFJO1FBQ0YsTUFBTWxDLGdCQUFnQjdFLDhEQUFVQSxDQUFDRCw2Q0FBRUEsRUFBRTtRQUNyQyxNQUFNaUgsTUFBTSxJQUFJNUQ7UUFFaEIsMkJBQTJCO1FBQzNCLE1BQU02RCxxQkFBcUI3Ryx5REFBS0EsQ0FDOUJ5RSxlQUNBeEUseURBQUtBLENBQUMsYUFBYSxNQUFNQyx5REFBU0EsQ0FBQzBELFFBQVEsQ0FBQ2dELE9BQzVDM0cseURBQUtBLENBQUMsVUFBVSxNQUFNO1FBR3hCLE1BQU02RyxnQkFBZ0IsTUFBTS9HLDJEQUFPQSxDQUFDOEc7UUFFcEMsd0JBQXdCO1FBQ3hCLE1BQU16QixRQUFRN0UsOERBQVVBLENBQUNaLDZDQUFFQTtRQUMzQm1ILGNBQWM5QyxJQUFJLENBQUMrQyxPQUFPLENBQUMsQ0FBQ2xIO1lBQzFCdUYsTUFBTTRCLE1BQU0sQ0FBQ25ILElBQUlvSCxHQUFHO1FBQ3RCO1FBRUEsSUFBSUgsY0FBYzlDLElBQUksQ0FBQ2tELE1BQU0sR0FBRyxHQUFHO1lBQ2pDLE1BQU05QixNQUFNaUIsTUFBTTtZQUNsQnhFLFFBQVEyRSxHQUFHLENBQUMsY0FBd0MsT0FBMUJNLGNBQWM5QyxJQUFJLENBQUNrRCxNQUFNLEVBQUM7UUFDdEQ7SUFDRixFQUFFLE9BQU90RixPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxxQ0FBcUNBO0lBQ3JEO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcemVyb1xcRG93bmxvYWRzXFxoZWFsdGhjYXJlLWRhc2hib2FyZFxcbGliXFxkb2N0b3Itc2NoZWR1bGluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkYiB9IGZyb20gXCJAL2xpYi9maXJlYmFzZVwiXHJcbmltcG9ydCB7XHJcbiAgY29sbGVjdGlvbixcclxuICBkb2MsXHJcbiAgZ2V0RG9jLFxyXG4gIGdldERvY3MsXHJcbiAgcXVlcnksXHJcbiAgd2hlcmUsXHJcbiAgVGltZXN0YW1wLFxyXG4gIHNldERvYyxcclxuICB1cGRhdGVEb2MsXHJcbiAgZGVsZXRlRG9jLFxyXG4gIHNlcnZlclRpbWVzdGFtcCxcclxuICB3cml0ZUJhdGNoLFxyXG59IGZyb20gXCJmaXJlYmFzZS9maXJlc3RvcmVcIlxyXG5pbXBvcnQgeyBmb3JtYXQsIGFkZE1pbnV0ZXMsIHN0YXJ0T2ZEYXksIGVuZE9mRGF5IH0gZnJvbSBcImRhdGUtZm5zXCJcclxuaW1wb3J0IHsgcHRCUiB9IGZyb20gXCJkYXRlLWZucy9sb2NhbGVcIlxyXG5cclxuLy8gSW50ZXJmYWNlIGZvciBkb2N0b3Igd29ya2luZyBob3Vyc1xyXG5pbnRlcmZhY2UgV29ya2luZ0hvdXJzIHtcclxuICBzdGFydDogc3RyaW5nXHJcbiAgZW5kOiBzdHJpbmdcclxufVxyXG5cclxuLy8gSW50ZXJmYWNlIGZvciBkb2N0b3Igc2NoZWR1bGVcclxuaW50ZXJmYWNlIERvY3RvclNjaGVkdWxlIHtcclxuICB3b3JraW5nRGF5czogc3RyaW5nW11cclxuICB3b3JraW5nSG91cnM6IFdvcmtpbmdIb3Vyc1xyXG4gIGlzMjRIb3Vycz86IGJvb2xlYW5cclxufVxyXG5cclxuLy8gSW50ZXJmYWNlIGZvciBhcHBvaW50bWVudCBzbG90XHJcbmludGVyZmFjZSBBcHBvaW50bWVudFNsb3Qge1xyXG4gIHRpbWU6IHN0cmluZ1xyXG4gIGlzQXZhaWxhYmxlOiBib29sZWFuXHJcbiAgaXNCbG9ja2VkPzogYm9vbGVhblxyXG4gIGJsb2NrZWRVbnRpbD86IERhdGVcclxufVxyXG5cclxuLyoqXHJcbiAqIEZldGNoZXMgZG9jdG9yIHdvcmtpbmcgaG91cnMgZnJvbSBGaXJlc3RvcmVcclxuICogQHBhcmFtIGNsaW5pY0lkIC0gVGhlIGNsaW5pYyBJRFxyXG4gKiBAcGFyYW0gZG9jdG9ySWQgLSBUaGUgZG9jdG9yIElEXHJcbiAqIEByZXR1cm5zIFRoZSBkb2N0b3IncyBzY2hlZHVsZSBpbmNsdWRpbmcgd29ya2luZyBkYXlzIGFuZCBob3Vyc1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoRG9jdG9yV29ya2luZ0hvdXJzKGNsaW5pY0lkOiBzdHJpbmcsIGRvY3RvcklkOiBzdHJpbmcpOiBQcm9taXNlPERvY3RvclNjaGVkdWxlPiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIFJlZmVyZW5jZSB0byB0aGUgZG9jdG9yIGRvY3VtZW50IGluIHRoZSBjbGluaWMncyBkb2N0b3JzIHN1YmNvbGxlY3Rpb25cclxuICAgIGNvbnN0IGRvY3RvclJlZiA9IGRvYyhkYiwgXCJjbGluaWNzXCIsIGNsaW5pY0lkLCBcImRvY3RvcnNcIiwgZG9jdG9ySWQpXHJcbiAgICBjb25zdCBkb2N0b3JEb2MgPSBhd2FpdCBnZXREb2MoZG9jdG9yUmVmKVxyXG5cclxuICAgIGlmICghZG9jdG9yRG9jLmV4aXN0cygpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRG9jdG9yIHdpdGggSUQgJHtkb2N0b3JJZH0gbm90IGZvdW5kIGluIGNsaW5pYyAke2NsaW5pY0lkfWApXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZG9jdG9yRGF0YSA9IGRvY3RvckRvYy5kYXRhKClcclxuXHJcbiAgICAvLyBFeHRyYWN0IHNjaGVkdWxlIGluZm9ybWF0aW9uXHJcbiAgICBjb25zdCB3b3JraW5nRGF5cyA9IGRvY3RvckRhdGEuc2NoZWR1bGU/LndvcmtpbmdEYXlzIHx8IFtcInNlZ3VuZGFcIiwgXCJ0ZXJjYVwiLCBcInF1YXJ0YVwiLCBcInF1aW50YVwiLCBcInNleHRhXCJdXHJcblxyXG4gICAgY29uc3Qgd29ya2luZ0hvdXJzID0gZG9jdG9yRGF0YS5zY2hlZHVsZT8ud29ya2luZ0hvdXJzIHx8IHtcclxuICAgICAgc3RhcnQ6IFwiMDg6MDBcIixcclxuICAgICAgZW5kOiBcIjE4OjAwXCIsXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaXMyNEhvdXJzID0gd29ya2luZ0hvdXJzLnN0YXJ0ID09PSBcIjAwOjAwXCIgJiYgd29ya2luZ0hvdXJzLmVuZCA9PT0gXCIyMzo1OVwiXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd29ya2luZ0RheXMsXHJcbiAgICAgIHdvcmtpbmdIb3VycyxcclxuICAgICAgaXMyNEhvdXJzLFxyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgZG9jdG9yIHdvcmtpbmcgaG91cnM6XCIsIGVycm9yKVxyXG4gICAgLy8gUmV0dXJuIGRlZmF1bHQgc2NoZWR1bGUgaWYgdGhlcmUncyBhbiBlcnJvclxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd29ya2luZ0RheXM6IFtcInNlZ3VuZGFcIiwgXCJ0ZXJjYVwiLCBcInF1YXJ0YVwiLCBcInF1aW50YVwiLCBcInNleHRhXCJdLFxyXG4gICAgICB3b3JraW5nSG91cnM6IHsgc3RhcnQ6IFwiMDg6MDBcIiwgZW5kOiBcIjE4OjAwXCIgfSxcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYXBwb2ludG1lbnQgc2xvdHMgYmFzZWQgb24gZG9jdG9yIHdvcmtpbmcgaG91cnNcclxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSBmb3Igd2hpY2ggdG8gZ2VuZXJhdGUgc2xvdHNcclxuICogQHBhcmFtIHNjaGVkdWxlIC0gVGhlIGRvY3RvcidzIHNjaGVkdWxlXHJcbiAqIEBwYXJhbSBzbG90RHVyYXRpb24gLSBEdXJhdGlvbiBvZiBlYWNoIHNsb3QgaW4gbWludXRlcyAoZGVmYXVsdDogMzApXHJcbiAqIEByZXR1cm5zIEFycmF5IG9mIGFwcG9pbnRtZW50IHNsb3RzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVBcHBvaW50bWVudFNsb3RzKGRhdGU6IERhdGUsIHNjaGVkdWxlOiBEb2N0b3JTY2hlZHVsZSwgc2xvdER1cmF0aW9uID0gMzApOiBBcHBvaW50bWVudFNsb3RbXSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHNsb3RzOiBBcHBvaW50bWVudFNsb3RbXSA9IFtdXHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHNlbGVjdGVkIGRhdGUgaXMgYSB3b3JraW5nIGRheVxyXG4gICAgY29uc3Qgd2Vla0RheSA9IGZvcm1hdChkYXRlLCBcIkVFRUVcIiwgeyBsb2NhbGU6IHB0QlIgfSlcclxuICAgICAgLnRvTG93ZXJDYXNlKClcclxuICAgICAgLm5vcm1hbGl6ZShcIk5GRFwiKVxyXG4gICAgICAucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgXCJcIilcclxuICAgICAgLnJlcGxhY2UoXCItZmVpcmFcIiwgXCJcIilcclxuXHJcbiAgICBpZiAoIXNjaGVkdWxlLndvcmtpbmdEYXlzLmluY2x1ZGVzKHdlZWtEYXkpKSB7XHJcbiAgICAgIHJldHVybiBzbG90cyAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgaWYgbm90IGEgd29ya2luZyBkYXlcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJzZSB3b3JraW5nIGhvdXJzXHJcbiAgICBjb25zdCBbc3RhcnRIb3VyLCBzdGFydE1pbnV0ZV0gPSBzY2hlZHVsZS53b3JraW5nSG91cnMuc3RhcnQuc3BsaXQoXCI6XCIpLm1hcChOdW1iZXIpXHJcbiAgICBjb25zdCBbZW5kSG91ciwgZW5kTWludXRlXSA9IHNjaGVkdWxlLndvcmtpbmdIb3Vycy5lbmQuc3BsaXQoXCI6XCIpLm1hcChOdW1iZXIpXHJcblxyXG4gICAgLy8gQ3JlYXRlIHN0YXJ0IGFuZCBlbmQgZGF0ZSBvYmplY3RzXHJcbiAgICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZShkYXRlKVxyXG4gICAgc3RhcnREYXRlLnNldEhvdXJzKHN0YXJ0SG91ciwgc3RhcnRNaW51dGUsIDAsIDApXHJcblxyXG4gICAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKGRhdGUpXHJcbiAgICBlbmREYXRlLnNldEhvdXJzKGVuZEhvdXIsIGVuZE1pbnV0ZSwgMCwgMClcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSBzbG90c1xyXG4gICAgbGV0IGN1cnJlbnRTbG90ID0gc3RhcnREYXRlXHJcbiAgICB3aGlsZSAoY3VycmVudFNsb3QgPCBlbmREYXRlKSB7XHJcbiAgICAgIHNsb3RzLnB1c2goe1xyXG4gICAgICAgIHRpbWU6IGZvcm1hdChjdXJyZW50U2xvdCwgXCJISDptbVwiKSxcclxuICAgICAgICBpc0F2YWlsYWJsZTogdHJ1ZSxcclxuICAgICAgfSlcclxuICAgICAgY3VycmVudFNsb3QgPSBhZGRNaW51dGVzKGN1cnJlbnRTbG90LCBzbG90RHVyYXRpb24pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNsb3RzXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZW5lcmF0aW5nIGFwcG9pbnRtZW50IHNsb3RzOlwiLCBlcnJvcilcclxuICAgIHJldHVybiBbXVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBhdmFpbGFiaWxpdHkgb2YgYXBwb2ludG1lbnQgc2xvdHMgaW4gRmlyZXN0b3JlXHJcbiAqIEBwYXJhbSBjbGluaWNJZCAtIFRoZSBjbGluaWMgSURcclxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBjaGVja1xyXG4gKiBAcGFyYW0gZG9jdG9ySWQgLSBUaGUgZG9jdG9yIElEIChvcHRpb25hbClcclxuICogQHJldHVybnMgQXJyYXkgb2YgYXZhaWxhYmxlIHRpbWUgc2xvdHNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja1Nsb3RzQXZhaWxhYmlsaXR5KGNsaW5pY0lkOiBzdHJpbmcsIGRhdGU6IERhdGUsIGRvY3RvcklkPzogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBHZXQgcmVmZXJlbmNlIHRvIGFwcG9pbnRtZW50cyBjb2xsZWN0aW9uXHJcbiAgICBjb25zdCBhcHBvaW50bWVudHNSZWYgPSBjb2xsZWN0aW9uKGRiLCBcImFwcG9pbnRtZW50c1wiKVxyXG5cclxuICAgIC8vIENyZWF0ZSBkYXRlIHJhbmdlIGZvciB0aGUgc2VsZWN0ZWQgZGF0ZVxyXG4gICAgY29uc3QgZGF5U3RhcnQgPSBzdGFydE9mRGF5KGRhdGUpXHJcbiAgICBjb25zdCBkYXlFbmQgPSBlbmRPZkRheShkYXRlKVxyXG5cclxuICAgIC8vIEJ1aWxkIHF1ZXJ5IGJhc2VkIG9uIHBhcmFtZXRlcnNcclxuICAgIGxldCBhcHBvaW50bWVudHNRdWVyeSA9IHF1ZXJ5KFxyXG4gICAgICBhcHBvaW50bWVudHNSZWYsXHJcbiAgICAgIHdoZXJlKFwiY2xpbmljSWRcIiwgXCI9PVwiLCBjbGluaWNJZCksXHJcbiAgICAgIHdoZXJlKFwiZGF0ZVwiLCBcIj49XCIsIFRpbWVzdGFtcC5mcm9tRGF0ZShkYXlTdGFydCkpLFxyXG4gICAgICB3aGVyZShcImRhdGVcIiwgXCI8PVwiLCBUaW1lc3RhbXAuZnJvbURhdGUoZGF5RW5kKSksXHJcbiAgICApXHJcblxyXG4gICAgLy8gQWRkIGRvY3RvciBmaWx0ZXIgaWYgcHJvdmlkZWRcclxuICAgIGlmIChkb2N0b3JJZCkge1xyXG4gICAgICBhcHBvaW50bWVudHNRdWVyeSA9IHF1ZXJ5KFxyXG4gICAgICAgIGFwcG9pbnRtZW50c1JlZixcclxuICAgICAgICB3aGVyZShcImNsaW5pY0lkXCIsIFwiPT1cIiwgY2xpbmljSWQpLFxyXG4gICAgICAgIHdoZXJlKFwiZG9jdG9ySWRcIiwgXCI9PVwiLCBkb2N0b3JJZCksXHJcbiAgICAgICAgd2hlcmUoXCJkYXRlXCIsIFwiPj1cIiwgVGltZXN0YW1wLmZyb21EYXRlKGRheVN0YXJ0KSksXHJcbiAgICAgICAgd2hlcmUoXCJkYXRlXCIsIFwiPD1cIiwgVGltZXN0YW1wLmZyb21EYXRlKGRheUVuZCkpLFxyXG4gICAgICApXHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXhlY3V0ZSBxdWVyeVxyXG4gICAgY29uc3QgYXBwb2ludG1lbnRzID0gYXdhaXQgZ2V0RG9jcyhhcHBvaW50bWVudHNRdWVyeSlcclxuXHJcbiAgICAvLyBFeHRyYWN0IGJvb2tlZCB0aW1lIHNsb3RzXHJcbiAgICBjb25zdCBib29rZWRTbG90cyA9IG5ldyBTZXQoYXBwb2ludG1lbnRzLmRvY3MubWFwKChkb2MpID0+IGZvcm1hdChkb2MuZGF0YSgpLmRhdGUudG9EYXRlKCksIFwiSEg6bW1cIikpKVxyXG5cclxuICAgIC8vIElmIGRvY3RvciBJRCBpcyBwcm92aWRlZCwgZ2V0IHRoZWlyIHNjaGVkdWxlXHJcbiAgICBsZXQgZG9jdG9yU2NoZWR1bGU6IERvY3RvclNjaGVkdWxlXHJcbiAgICBpZiAoZG9jdG9ySWQpIHtcclxuICAgICAgZG9jdG9yU2NoZWR1bGUgPSBhd2FpdCBmZXRjaERvY3RvcldvcmtpbmdIb3VycyhjbGluaWNJZCwgZG9jdG9ySWQpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBEZWZhdWx0IHNjaGVkdWxlIGlmIG5vIGRvY3RvciBzcGVjaWZpZWRcclxuICAgICAgZG9jdG9yU2NoZWR1bGUgPSB7XHJcbiAgICAgICAgd29ya2luZ0RheXM6IFtcInNlZ3VuZGFcIiwgXCJ0ZXJjYVwiLCBcInF1YXJ0YVwiLCBcInF1aW50YVwiLCBcInNleHRhXCJdLFxyXG4gICAgICAgIHdvcmtpbmdIb3VyczogeyBzdGFydDogXCIwODowMFwiLCBlbmQ6IFwiMTg6MDBcIiB9LFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgYWxsIHBvc3NpYmxlIHNsb3RzIGZvciB0aGUgZGF5XHJcbiAgICBjb25zdCBhbGxTbG90cyA9IGdlbmVyYXRlQXBwb2ludG1lbnRTbG90cyhkYXRlLCBkb2N0b3JTY2hlZHVsZSlcclxuXHJcbiAgICAvLyBGaWx0ZXIgb3V0IGJvb2tlZCBzbG90c1xyXG4gICAgcmV0dXJuIGFsbFNsb3RzLmZpbHRlcigoc2xvdCkgPT4gIWJvb2tlZFNsb3RzLmhhcyhzbG90LnRpbWUpKS5tYXAoKHNsb3QpID0+IHNsb3QudGltZSlcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNoZWNraW5nIHNsb3RzIGF2YWlsYWJpbGl0eTpcIiwgZXJyb3IpXHJcbiAgICByZXR1cm4gW11cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUZW1wb3JhcmlseSBibG9ja3MgYSB0aW1lIHNsb3QgdG8gcHJldmVudCBkb3VibGUgYm9va2luZ3NcclxuICogQHBhcmFtIGNsaW5pY0lkIC0gVGhlIGNsaW5pYyBJRFxyXG4gKiBAcGFyYW0gZG9jdG9ySWQgLSBUaGUgZG9jdG9yIElEXHJcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGFwcG9pbnRtZW50IGRhdGVcclxuICogQHBhcmFtIHRpbWUgLSBUaGUgYXBwb2ludG1lbnQgdGltZVxyXG4gKiBAcGFyYW0gYmxvY2tEdXJhdGlvbiAtIEhvdyBsb25nIHRvIGJsb2NrIHRoZSBzbG90IGluIG1pbnV0ZXMgKGRlZmF1bHQ6IDEwKVxyXG4gKiBAcmV0dXJucyBJRCBvZiB0aGUgdGVtcG9yYXJ5IGJsb2NrIGRvY3VtZW50XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYmxvY2tUaW1lU2xvdChcclxuICBjbGluaWNJZDogc3RyaW5nLFxyXG4gIGRvY3RvcklkOiBzdHJpbmcsXHJcbiAgZGF0ZTogRGF0ZSxcclxuICB0aW1lOiBzdHJpbmcsXHJcbiAgYmxvY2tEdXJhdGlvbiA9IDEwLFxyXG4pOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDcmVhdGUgYSByZWZlcmVuY2UgdG8gdGhlIHRlbXBvcmFyeSBibG9ja3MgY29sbGVjdGlvblxyXG4gICAgY29uc3QgdGVtcEJsb2Nrc1JlZiA9IGNvbGxlY3Rpb24oZGIsIFwidGVtcG9yYXJ5QmxvY2tzXCIpXHJcblxyXG4gICAgLy8gUGFyc2UgdGltZSBhbmQgY3JlYXRlIGEgRGF0ZSBvYmplY3RcclxuICAgIGNvbnN0IFtob3VycywgbWludXRlc10gPSB0aW1lLnNwbGl0KFwiOlwiKS5tYXAoTnVtYmVyKVxyXG4gICAgY29uc3QgYXBwb2ludG1lbnREYXRlID0gbmV3IERhdGUoZGF0ZSlcclxuICAgIGFwcG9pbnRtZW50RGF0ZS5zZXRIb3Vycyhob3VycywgbWludXRlcywgMCwgMClcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgZXhwaXJhdGlvbiB0aW1lXHJcbiAgICBjb25zdCBleHBpcmF0aW9uVGltZSA9IGFkZE1pbnV0ZXMobmV3IERhdGUoKSwgYmxvY2tEdXJhdGlvbilcclxuXHJcbiAgICAvLyBDcmVhdGUgYSB1bmlxdWUgSUQgZm9yIHRoZSBibG9ja1xyXG4gICAgY29uc3QgYmxvY2tJZCA9IGAke2NsaW5pY0lkfV8ke2RvY3RvcklkfV8ke2Zvcm1hdChhcHBvaW50bWVudERhdGUsIFwieXl5eS1NTS1kZF9ISC1tbVwiKX1gXHJcblxyXG4gICAgLy8gQ3JlYXRlIHRoZSBibG9jayBkb2N1bWVudFxyXG4gICAgYXdhaXQgc2V0RG9jKGRvYyh0ZW1wQmxvY2tzUmVmLCBibG9ja0lkKSwge1xyXG4gICAgICBjbGluaWNJZCxcclxuICAgICAgZG9jdG9ySWQsXHJcbiAgICAgIGRhdGU6IFRpbWVzdGFtcC5mcm9tRGF0ZShhcHBvaW50bWVudERhdGUpLFxyXG4gICAgICB0aW1lLFxyXG4gICAgICBibG9ja2VkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxyXG4gICAgICBleHBpcmVzQXQ6IFRpbWVzdGFtcC5mcm9tRGF0ZShleHBpcmF0aW9uVGltZSksXHJcbiAgICAgIHN0YXR1czogXCJibG9ja2VkXCIsXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiBibG9ja0lkXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBibG9ja2luZyB0aW1lIHNsb3Q6XCIsIGVycm9yKVxyXG4gICAgdGhyb3cgZXJyb3JcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTY2hlZHVsZXMgYW4gYXBwb2ludG1lbnQgaW4gRmlyZXN0b3JlXHJcbiAqIEBwYXJhbSBhcHBvaW50bWVudERhdGEgLSBUaGUgYXBwb2ludG1lbnQgZGF0YVxyXG4gKiBAcGFyYW0gYmxvY2tJZCAtIElEIG9mIHRoZSB0ZW1wb3JhcnkgYmxvY2sgKG9wdGlvbmFsKVxyXG4gKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBhcHBvaW50bWVudCBhbmQgY29uc3VsdGF0aW9uIElEc1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNjaGVkdWxlQXBwb2ludG1lbnQoXHJcbiAgYXBwb2ludG1lbnREYXRhOiBhbnksXHJcbiAgYmxvY2tJZD86IHN0cmluZyxcclxuKTogUHJvbWlzZTx7IGFwcG9pbnRtZW50SWQ6IHN0cmluZzsgY29uc3VsdGF0aW9uSWQ6IHN0cmluZyB9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGJhdGNoID0gd3JpdGVCYXRjaChkYilcclxuXHJcbiAgICAvLyBDcmVhdGUgYXBwb2ludG1lbnQgZG9jdW1lbnRcclxuICAgIGNvbnN0IGFwcG9pbnRtZW50c1JlZiA9IGNvbGxlY3Rpb24oZGIsIFwiYXBwb2ludG1lbnRzXCIpXHJcbiAgICBjb25zdCBhcHBvaW50bWVudFJlZiA9IGRvYyhhcHBvaW50bWVudHNSZWYpXHJcblxyXG4gICAgLy8gQ3JlYXRlIGNvbnN1bHRhdGlvbiBkb2N1bWVudFxyXG4gICAgY29uc3QgY29uc3VsdGF0aW9uc1JlZiA9IGNvbGxlY3Rpb24oZGIsIFwiY29uc3VsdGF0aW9uc1wiKVxyXG4gICAgY29uc3QgY29uc3VsdGF0aW9uUmVmID0gZG9jKGNvbnN1bHRhdGlvbnNSZWYpXHJcblxyXG4gICAgLy8gUGFyc2UgZGF0ZSBhbmQgdGltZVxyXG4gICAgY29uc3QgZGF0ZVRpbWUgPSBuZXcgRGF0ZShgJHtmb3JtYXQoYXBwb2ludG1lbnREYXRhLmRhdGUsIFwieXl5eS1NTS1kZFwiKX1UJHthcHBvaW50bWVudERhdGEudGltZX1gKVxyXG5cclxuICAgIC8vIFByZXBhcmUgYXBwb2ludG1lbnQgZGF0YVxyXG4gICAgY29uc3QgYXBwb2ludG1lbnREb2MgPSB7XHJcbiAgICAgIGlkOiBhcHBvaW50bWVudFJlZi5pZCxcclxuICAgICAgdHlwZTogXCJjb25zdWx0YXRpb25cIixcclxuICAgICAgY29uc3VsdGF0aW9uSWQ6IGNvbnN1bHRhdGlvblJlZi5pZCxcclxuICAgICAgY2xpbmljSWQ6IGFwcG9pbnRtZW50RGF0YS5jbGluaWNJZCxcclxuICAgICAgZG9jdG9ySWQ6IGFwcG9pbnRtZW50RGF0YS5kb2N0b3JJZCxcclxuICAgICAgcGF0aWVudE5hbWU6IGFwcG9pbnRtZW50RGF0YS5wYXRpZW50TmFtZSxcclxuICAgICAgZGF0ZTogVGltZXN0YW1wLmZyb21EYXRlKGRhdGVUaW1lKSxcclxuICAgICAgZHVyYXRpb246IDMwLFxyXG4gICAgICBzdGF0dXM6IFwiQWdlbmRhZG9cIixcclxuICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcmVwYXJlIGNvbnN1bHRhdGlvbiBkYXRhXHJcbiAgICBjb25zdCBjb25zdWx0YXRpb25Eb2MgPSB7XHJcbiAgICAgIGlkOiBjb25zdWx0YXRpb25SZWYuaWQsXHJcbiAgICAgIGFwcG9pbnRtZW50SWQ6IGFwcG9pbnRtZW50UmVmLmlkLFxyXG4gICAgICAuLi5hcHBvaW50bWVudERhdGEsXHJcbiAgICAgIGRhdGU6IFRpbWVzdGFtcC5mcm9tRGF0ZShkYXRlVGltZSksXHJcbiAgICAgIHN0YXR1czogXCJBZ2VuZGFkb1wiLFxyXG4gICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBkb2N1bWVudHMgdG8gYmF0Y2hcclxuICAgIGJhdGNoLnNldChhcHBvaW50bWVudFJlZiwgYXBwb2ludG1lbnREb2MpXHJcbiAgICBiYXRjaC5zZXQoY29uc3VsdGF0aW9uUmVmLCBjb25zdWx0YXRpb25Eb2MpXHJcblxyXG4gICAgLy8gSWYgdGhlcmUncyBhIGJsb2NrIElELCB1cGRhdGUgaXRzIHN0YXR1c1xyXG4gICAgaWYgKGJsb2NrSWQpIHtcclxuICAgICAgY29uc3QgYmxvY2tSZWYgPSBkb2MoZGIsIFwidGVtcG9yYXJ5QmxvY2tzXCIsIGJsb2NrSWQpXHJcbiAgICAgIGJhdGNoLnVwZGF0ZShibG9ja1JlZiwge1xyXG4gICAgICAgIHN0YXR1czogXCJjb25maXJtZWRcIixcclxuICAgICAgICBhcHBvaW50bWVudElkOiBhcHBvaW50bWVudFJlZi5pZCxcclxuICAgICAgICBjb25zdWx0YXRpb25JZDogY29uc3VsdGF0aW9uUmVmLmlkLFxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbW1pdCB0aGUgYmF0Y2hcclxuICAgIGF3YWl0IGJhdGNoLmNvbW1pdCgpXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYXBwb2ludG1lbnRJZDogYXBwb2ludG1lbnRSZWYuaWQsXHJcbiAgICAgIGNvbnN1bHRhdGlvbklkOiBjb25zdWx0YXRpb25SZWYuaWQsXHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzY2hlZHVsaW5nIGFwcG9pbnRtZW50OlwiLCBlcnJvcilcclxuICAgIHRocm93IGVycm9yXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVW5ibG9ja3MgYSB0aW1lIHNsb3QgYWZ0ZXIgc2NoZWR1bGluZyBvciBjYW5jZWxsYXRpb25cclxuICogQHBhcmFtIGJsb2NrSWQgLSBJRCBvZiB0aGUgdGVtcG9yYXJ5IGJsb2NrXHJcbiAqIEBwYXJhbSBzdGF0dXMgLSBOZXcgc3RhdHVzIGZvciB0aGUgYmxvY2sgKGNvbmZpcm1lZCwgY2FuY2VsbGVkLCBleHBpcmVkKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVuYmxvY2tUaW1lU2xvdChibG9ja0lkOiBzdHJpbmcsIHN0YXR1czogXCJjb25maXJtZWRcIiB8IFwiY2FuY2VsbGVkXCIgfCBcImV4cGlyZWRcIik6IFByb21pc2U8dm9pZD4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBibG9ja1JlZiA9IGRvYyhkYiwgXCJ0ZW1wb3JhcnlCbG9ja3NcIiwgYmxvY2tJZClcclxuICAgIGNvbnN0IGJsb2NrRG9jID0gYXdhaXQgZ2V0RG9jKGJsb2NrUmVmKVxyXG5cclxuICAgIC8vIElmIGJsb2NrIGRvZXNuJ3QgZXhpc3QsIGl0IG1pZ2h0IGhhdmUgYmVlbiBhbHJlYWR5IGNsZWFuZWQgdXAgb3IgZXhwaXJlZFxyXG4gICAgaWYgKCFibG9ja0RvYy5leGlzdHMoKSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhgQmxvY2sgJHtibG9ja0lkfSBub3QgZm91bmQgLSBtaWdodCBoYXZlIGJlZW4gYWxyZWFkeSBjbGVhbmVkIHVwIG9yIGV4cGlyZWRgKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhdHVzID09PSBcImNvbmZpcm1lZFwiIHx8IHN0YXR1cyA9PT0gXCJjYW5jZWxsZWRcIikge1xyXG4gICAgICBhd2FpdCB1cGRhdGVEb2MoYmxvY2tSZWYsIHtcclxuICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcclxuICAgICAgfSlcclxuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcImV4cGlyZWRcIikge1xyXG4gICAgICBhd2FpdCBkZWxldGVEb2MoYmxvY2tSZWYpXHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1bmJsb2NraW5nIHRpbWUgc2xvdDpcIiwgZXJyb3IpXHJcbiAgICAvLyBEb24ndCB0aHJvdyBlcnJvciBmb3Igbm9uLWNyaXRpY2FsIG9wZXJhdGlvblxyXG4gICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gdW5ibG9jayBzbG90ICR7YmxvY2tJZH0sIGJ1dCBjb250aW51aW5nIG9wZXJhdGlvbmApXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2xlYW5zIHVwIGV4cGlyZWQgdGVtcG9yYXJ5IGJsb2Nrc1xyXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgcGVyaW9kaWNhbGx5LCBlLmcuLCBieSBhIHNjaGVkdWxlZCBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFudXBFeHBpcmVkQmxvY2tzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB0ZW1wQmxvY2tzUmVmID0gY29sbGVjdGlvbihkYiwgXCJ0ZW1wb3JhcnlCbG9ja3NcIilcclxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcclxuXHJcbiAgICAvLyBRdWVyeSBmb3IgZXhwaXJlZCBibG9ja3NcclxuICAgIGNvbnN0IGV4cGlyZWRCbG9ja3NRdWVyeSA9IHF1ZXJ5KFxyXG4gICAgICB0ZW1wQmxvY2tzUmVmLFxyXG4gICAgICB3aGVyZShcImV4cGlyZXNBdFwiLCBcIjw9XCIsIFRpbWVzdGFtcC5mcm9tRGF0ZShub3cpKSxcclxuICAgICAgd2hlcmUoXCJzdGF0dXNcIiwgXCI9PVwiLCBcImJsb2NrZWRcIiksXHJcbiAgICApXHJcblxyXG4gICAgY29uc3QgZXhwaXJlZEJsb2NrcyA9IGF3YWl0IGdldERvY3MoZXhwaXJlZEJsb2Nrc1F1ZXJ5KVxyXG5cclxuICAgIC8vIERlbGV0ZSBleHBpcmVkIGJsb2Nrc1xyXG4gICAgY29uc3QgYmF0Y2ggPSB3cml0ZUJhdGNoKGRiKVxyXG4gICAgZXhwaXJlZEJsb2Nrcy5kb2NzLmZvckVhY2goKGRvYykgPT4ge1xyXG4gICAgICBiYXRjaC5kZWxldGUoZG9jLnJlZilcclxuICAgIH0pXHJcblxyXG4gICAgaWYgKGV4cGlyZWRCbG9ja3MuZG9jcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGF3YWl0IGJhdGNoLmNvbW1pdCgpXHJcbiAgICAgIGNvbnNvbGUubG9nKGBDbGVhbmVkIHVwICR7ZXhwaXJlZEJsb2Nrcy5kb2NzLmxlbmd0aH0gZXhwaXJlZCBibG9ja3NgKVxyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2xlYW5pbmcgdXAgZXhwaXJlZCBibG9ja3M6XCIsIGVycm9yKVxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiZGIiLCJjb2xsZWN0aW9uIiwiZG9jIiwiZ2V0RG9jIiwiZ2V0RG9jcyIsInF1ZXJ5Iiwid2hlcmUiLCJUaW1lc3RhbXAiLCJzZXREb2MiLCJ1cGRhdGVEb2MiLCJkZWxldGVEb2MiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJ3cml0ZUJhdGNoIiwiZm9ybWF0IiwiYWRkTWludXRlcyIsInN0YXJ0T2ZEYXkiLCJlbmRPZkRheSIsInB0QlIiLCJmZXRjaERvY3RvcldvcmtpbmdIb3VycyIsImNsaW5pY0lkIiwiZG9jdG9ySWQiLCJkb2N0b3JEYXRhIiwiZG9jdG9yUmVmIiwiZG9jdG9yRG9jIiwiZXhpc3RzIiwiRXJyb3IiLCJkYXRhIiwid29ya2luZ0RheXMiLCJzY2hlZHVsZSIsIndvcmtpbmdIb3VycyIsInN0YXJ0IiwiZW5kIiwiaXMyNEhvdXJzIiwiZXJyb3IiLCJjb25zb2xlIiwiZ2VuZXJhdGVBcHBvaW50bWVudFNsb3RzIiwiZGF0ZSIsInNsb3REdXJhdGlvbiIsInNsb3RzIiwid2Vla0RheSIsImxvY2FsZSIsInRvTG93ZXJDYXNlIiwibm9ybWFsaXplIiwicmVwbGFjZSIsImluY2x1ZGVzIiwic3RhcnRIb3VyIiwic3RhcnRNaW51dGUiLCJzcGxpdCIsIm1hcCIsIk51bWJlciIsImVuZEhvdXIiLCJlbmRNaW51dGUiLCJzdGFydERhdGUiLCJEYXRlIiwic2V0SG91cnMiLCJlbmREYXRlIiwiY3VycmVudFNsb3QiLCJwdXNoIiwidGltZSIsImlzQXZhaWxhYmxlIiwiY2hlY2tTbG90c0F2YWlsYWJpbGl0eSIsImFwcG9pbnRtZW50c1JlZiIsImRheVN0YXJ0IiwiZGF5RW5kIiwiYXBwb2ludG1lbnRzUXVlcnkiLCJmcm9tRGF0ZSIsImFwcG9pbnRtZW50cyIsImJvb2tlZFNsb3RzIiwiU2V0IiwiZG9jcyIsInRvRGF0ZSIsImRvY3RvclNjaGVkdWxlIiwiYWxsU2xvdHMiLCJmaWx0ZXIiLCJzbG90IiwiaGFzIiwiYmxvY2tUaW1lU2xvdCIsImJsb2NrRHVyYXRpb24iLCJ0ZW1wQmxvY2tzUmVmIiwiaG91cnMiLCJtaW51dGVzIiwiYXBwb2ludG1lbnREYXRlIiwiZXhwaXJhdGlvblRpbWUiLCJibG9ja0lkIiwiYmxvY2tlZEF0IiwiZXhwaXJlc0F0Iiwic3RhdHVzIiwic2NoZWR1bGVBcHBvaW50bWVudCIsImFwcG9pbnRtZW50RGF0YSIsImJhdGNoIiwiYXBwb2ludG1lbnRSZWYiLCJjb25zdWx0YXRpb25zUmVmIiwiY29uc3VsdGF0aW9uUmVmIiwiZGF0ZVRpbWUiLCJhcHBvaW50bWVudERvYyIsImlkIiwidHlwZSIsImNvbnN1bHRhdGlvbklkIiwicGF0aWVudE5hbWUiLCJkdXJhdGlvbiIsImNyZWF0ZWRBdCIsImNvbnN1bHRhdGlvbkRvYyIsImFwcG9pbnRtZW50SWQiLCJzZXQiLCJibG9ja1JlZiIsInVwZGF0ZSIsImNvbW1pdCIsInVuYmxvY2tUaW1lU2xvdCIsImJsb2NrRG9jIiwibG9nIiwidXBkYXRlZEF0Iiwid2FybiIsImNsZWFudXBFeHBpcmVkQmxvY2tzIiwibm93IiwiZXhwaXJlZEJsb2Nrc1F1ZXJ5IiwiZXhwaXJlZEJsb2NrcyIsImZvckVhY2giLCJkZWxldGUiLCJyZWYiLCJsZW5ndGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/doctor-scheduling.ts\n"));

/***/ })

});